; /d/progs/sdcc/bin/as31.exe -l ./pixel_play_boy.a31


;
; STC15F2K60S2 specific definitions
;


.equ    P0M0, 0x94
.equ    P0M1, 0x93

.equ    P1M0, 0x92
.equ    P1M1, 0x91

.equ    P2M0, 0x96
.equ    P2M1, 0x95

.equ    P3M0, 0xB2
.equ    P3M1, 0xB1

.equ    P4, 0xC0
.equ    P4M0, 0xB4
.equ    P4M1, 0xB3

.equ    P5, 0xC8
.equ    P5M0, 0xCA
.equ    P5M1, 0xC9

; | T0x12 | T1x12 | UART_M0x6 | T2R | T2_C/~T | T2x12 | EXTRAM | S1ST2 |
.equ    AUXR,           0x8E
.equ    AUXR_T0x12,     (1 << 7)
.equ    AUXR_T2x12,     (1 << 2)
.equ    AUXR_T2R,       (1 << 4)

; | - | EX4 | EX3 | EX2 | - | T2CLKO | T1CLKO | T0CLKO |
.equ    INT_CLKO,       0x8F
.equ    INT_CLKO_T0CLKO,(1)

; | - | ET4 | ET3 | ES4 | ES3 | ET2 | ESPI | ES2 |
.equ    IE2,            0xAF
.equ    IE2_ET2,        (1 << 2)
.equ    IE2_ET3,        (1 << 5)
.equ    IE2_ET4,        (1 << 6)

.equ    T2L,            0xD7
.equ    T2H,            0xD6




;
; Board layout definitions
;



.flag   BEEPER, P3.5        ; Beeper output, DIFFERENT FROM ORIGINAL LAYOUT

; Buttons
.flag BTN_UP,           P3.2
.flag BTN_DOWN,         P3.6
.flag BTN_RIGHT,        P3.3
.flag BTN_LEFT,         P3.0
.flag BTN_OK,           P3.7

; Display rows
.flag DISPLAY_R0,       P2.6
.flag DISPLAY_R1,       P4.5
.flag DISPLAY_R2,       P0.4
.flag DISPLAY_R3,       P2.7
.flag DISPLAY_R4,       P0.0
.flag DISPLAY_R5,       P0.3
.flag DISPLAY_R6,       P0.1
.flag DISPLAY_R7,       P0.2
.flag DISPLAY_R8,       P0.5
.flag DISPLAY_R9,       P0.7
.flag DISPLAY_R10,      P1.3
.flag DISPLAY_R11,      P0.6
.flag DISPLAY_R12,      P1.0
.flag DISPLAY_R13,      P1.2
.flag DISPLAY_R14,      P1.1
.flag DISPLAY_R15,      P1.6

; Display columns
.flag DISPLAY_C0,       P2.4
.flag DISPLAY_C1,       P2.0
.flag DISPLAY_C2,       P4.4
.flag DISPLAY_C3,       P2.1
.flag DISPLAY_C4,       P1.4
.flag DISPLAY_C5,       P2.2
.flag DISPLAY_C6,       P4.1
.flag DISPLAY_C7,       P1.5

; Display digits
.flag DISPLAY_D0,       P2.3
.flag DISPLAY_D1,       P2.5
.flag DISPLAY_D2,       P4.2

; Display digit segments (overlap with matrix columns)
.flag SMG_A,            P4.1
.flag SMG_B,            P2.4
.flag SMG_C,            P2.1
.flag SMG_D,            P2.0
.flag SMG_E,            P4.4
.flag SMG_F,            P2.2
.flag SMG_G,            P1.4

.flag SMG_DP,           P1.5 ; Missing on original board


;
; 7-segment display definitions
;

.equ    SS_SEGN_A, 0
.equ    SS_SEGN_B, 1
.equ    SS_SEGN_C, 2
.equ    SS_SEGN_D, 3
.equ    SS_SEGN_E, 4
.equ    SS_SEGN_F, 5
.equ    SS_SEGN_G, 6

.equ    SS_SEGN_DP, 7

.equ    SS_SEGB_A, (1 << SS_SEGN_A)
.equ    SS_SEGB_B, (1 << SS_SEGN_B)
.equ    SS_SEGB_C, (1 << SS_SEGN_C)
.equ    SS_SEGB_D, (1 << SS_SEGN_D)
.equ    SS_SEGB_E, (1 << SS_SEGN_E)
.equ    SS_SEGB_F, (1 << SS_SEGN_F)
.equ    SS_SEGB_G, (1 << SS_SEGN_G)

.equ    SS_SEGB_DP, (1 << SS_SEGN_DP)

.equ    SS_CHR_0, SS_SEGB_A | SS_SEGB_B | SS_SEGB_C | SS_SEGB_D | SS_SEGB_E | SS_SEGB_F
.equ    SS_CHR_1, SS_SEGB_B | SS_SEGB_C
.equ    SS_CHR_2, SS_SEGB_A | SS_SEGB_B | SS_SEGB_G | SS_SEGB_E | SS_SEGB_D
.equ    SS_CHR_3, SS_SEGB_A | SS_SEGB_B | SS_SEGB_C | SS_SEGB_D | SS_SEGB_G
.equ    SS_CHR_4, SS_SEGB_B | SS_SEGB_C | SS_SEGB_F | SS_SEGB_G
.equ    SS_CHR_5, SS_SEGB_A | SS_SEGB_F | SS_SEGB_G | SS_SEGB_C | SS_SEGB_D
.equ    SS_CHR_6, SS_SEGB_A | SS_SEGB_F | SS_SEGB_G | SS_SEGB_C | SS_SEGB_D | SS_SEGB_E
.equ    SS_CHR_7, SS_SEGB_A | SS_SEGB_B | SS_SEGB_C
.equ    SS_CHR_8, SS_SEGB_A | SS_SEGB_B | SS_SEGB_C | SS_SEGB_D | SS_SEGB_E | SS_SEGB_F | SS_SEGB_G
.equ    SS_CHR_9, SS_SEGB_A | SS_SEGB_B | SS_SEGB_C | SS_SEGB_D | SS_SEGB_F | SS_SEGB_G

.equ    SS_CHR_MINUS, SS_SEGB_G

.equ    SS_CHR_A, SS_SEGB_A | SS_SEGB_B | SS_SEGB_C | SS_SEGB_F | SS_SEGB_G
.equ    SS_CHR_B, SS_SEGB_C | SS_SEGB_D | SS_SEGB_F | SS_SEGB_G
.equ    SS_CHR_C_UP, SS_SEGB_A | SS_SEGB_D | SS_SEGB_E | SS_SEGB_F
.equ    SS_CHR_C_LOW, SS_SEGB_D | SS_SEGB_E | SS_SEGB_G
.equ    SS_CHR_D, SS_SEGB_B | SS_SEGB_C | SS_SEGB_D | SS_SEGB_E | SS_SEGB_G
.equ    SS_CHR_E, SS_SEGB_A | SS_SEGB_D | SS_SEGB_E | SS_SEGB_F | SS_SEGB_G
.equ    SS_CHR_F, SS_SEGB_A | SS_SEGB_E | SS_SEGB_F | SS_SEGB_G
.equ    SS_CHR_G, SS_SEGB_A | SS_SEGB_C | SS_SEGB_D | SS_SEGB_E | SS_SEGB_F

.equ    SS_CHR_O_UP, SS_CHR_0
.equ    SS_CHR_O_LOW, SS_SEGB_C | SS_SEGB_D | SS_SEGB_E | SS_SEGB_G
.equ    SS_CHR_U_UP, SS_SEGB_B | SS_SEGB_C | SS_SEGB_D | SS_SEGB_E | SS_SEGB_F
.equ    SS_CHR_U_LOW, SS_SEGB_C | SS_SEGB_D | SS_SEGB_E

;
; Memory layout
;

.equ    stack_bottom, 0x7f                      ; Stack takes the top half of internal RAM

; Variables

.equ    tempo_tick, stack_bottom                ; Tempo tick counter

.equ    display_coro_pch, tempo_tick - 1        ; Display co-routine program counter
.equ    display_coro_pcl, display_coro_pch - 1

.equ    ss_anim_value_2, display_coro_pcl - 1   ; Characters to display on seven-segment display (in animation mode)
.equ    ss_anim_value_1, ss_anim_value_2 - 1
.equ    ss_anim_value_0, ss_anim_value_1 - 1

.equ    seq_notes, ss_anim_value_0 - 16         ; Current sequence of notes.
                                                ; 16 notes, one byte per note, [0;7] each,
                                                ; where 0 is silence, 1..7 are pitches of current scale

.equ    seq_cursor, seq_notes - 1               ; Index of currently playing note in `seq_notes`
.equ    seq_edit_cursor, seq_cursor - 1         ; Index of currently edited note in `seq_note`
                                                ; Outside of [0;15] range if not editing note
.equ    display_blink_cnt, seq_edit_cursor - 1  ; Cursor blinking counter

.equ    btns_denoise_buffer, display_blink_cnt - 4  ; A buffer for button jitter filtering

.equ    anim_counter, btns_denoise_buffer - 1   ; Animation frames counter
.equ    anim_ptr, anim_counter - 1

.equ    ss_menu_value_2, anim_ptr - 1           ; Characters to display on seven-segment display (in menu mode)
.equ    ss_menu_value_1, ss_menu_value_2 - 1
.equ    ss_menu_value_0, ss_menu_value_1 - 1

.equ    tempo_index, ss_menu_value_0 - 1        ; Tempo index



; Bit-addressable variables

.equ    aux_bits, 0x2F                          ; Highest bit-addressable register

.flag   display_blink_on, aux_bits.0            ; If blinking element on display should be enabled
.flag   display_ss_menu_mode, aux_bits.1        ; If true - SS display shows characters from ss_menu_value_* else from ss_anim_value_*

.equ    btns_pressed, aux_bits - 1              ; Buttons currently pressed

.flag   btn_pressed_ok, btns_pressed.0
.flag   btn_pressed_up, btns_pressed.1
.flag   btn_pressed_down, btns_pressed.2
.flag   btn_pressed_right, btns_pressed.3
.flag   btn_pressed_left, btns_pressed.4

.equ    btns_just_pressed, btns_pressed - 1     ; Buttons pressed since last check

.flag   btn_just_pressed_ok, btns_just_pressed.0
.flag   btn_just_pressed_up, btns_just_pressed.1
.flag   btn_just_pressed_down, btns_just_pressed.2
.flag   btn_just_pressed_right, btns_just_pressed.3
.flag   btn_just_pressed_left, btns_just_pressed.4

;
; Interrupt handlers
;



.org 0x0000             ; Reset handler
    ljmp    main

;.org 0x000B             ; Timer 0 interrupt - not used, T0 outputs tone to BEEPER using hardware connection
;    cpl     BEEPER
;    reti

.org 0x001B             ; Timer 1 interrupt - triggered on every 1/16 note - switch note, update animation
    djnz    tempo_tick, _t1i_no_next_note   ; if (--tempo_tick) goto _t1i_no_next_note

    push    ACC
    push    0
    push    DPL
    push    DPH

    lcall   tempo_reset_soft_counter

    mov     A, seq_cursor
    inc     A
    anl     A, #0x0f
    mov     seq_cursor, A

    lcall   animation_frame

    lcall   setup_current_note


    pop     DPH
    pop     DPL
    pop     0
    pop     ACC
_t1i_no_next_note:
    reti

.org 0x0063             ; Timer 2 interrupt - update display, check input
    push    ACC
    push    0
    push    DPL
    push    DPH

    lcall display_coro_run
    lcall input_check

    pop     DPH
    pop     DPL
    pop     0
    pop     ACC
    reti





;
; Entry point
;
main:

; Hardware initialization

; Stack init
    mov     SP, #stack_bottom

; Tempo counter init
    lcall   tempo_init

; Display setup
    mov     P0M0, #0xFF         ; set display pin modes to push-pull
    mov     P1M0, #0xFF
    mov     P2M0, #0xFF
    mov     P4M0, #0xFF
    lcall display_coro_start    ; start display coroutine
    mov     T2H, #0xFE          ; start display timer (T2)
    mov     T2L, #0
    orl     AUXR, #AUXR_T2R
    orl     IE2, #IE2_ET2

    lcall   animation_init

; Sequence setup
    mov     (seq_notes + 0), #1
    mov     (seq_notes + 1), #2
    mov     (seq_notes + 2), #3
    mov     (seq_notes + 3), #4
    mov     (seq_notes + 4), #5
    mov     (seq_notes + 5), #6
    mov     (seq_notes + 6), #7
    mov     (seq_notes + 7), #0
    mov     (seq_notes + 8), #1
    mov     (seq_notes + 9), #2
    mov     (seq_notes + 10), #3
    mov     (seq_notes + 11), #4
    mov     (seq_notes + 12), #5
    mov     (seq_notes + 13), #6
    mov     (seq_notes + 14), #7
    mov     (seq_notes + 15), #0

    mov     seq_cursor, #0
    mov     seq_edit_cursor, #2

    lcall   setup_current_note

;
    setb    EA          ; Enable interrupts
    
    sjmp    interaction_edit_notes

interaction_edit_notes:
    anl     seq_edit_cursor, #0x0F
    clr     display_ss_menu_mode
    clr     btn_just_pressed_ok

interaction_edit_notes_loop:
    jb      btn_just_pressed_up, interaction_edit_notes_cursor_up
    jb      btn_just_pressed_down, interaction_edit_notes_cursor_down
    jb      btn_just_pressed_right, interaction_edit_notes_note_up
    jb      btn_just_pressed_left, interaction_edit_notes_note_down
    jb      btn_just_pressed_ok, interaction_edit_tempo
    sjmp    interaction_edit_notes_loop

interaction_edit_notes_cursor_up:
    clr     btn_just_pressed_up
    mov     A, seq_edit_cursor
    dec     A
    anl     A, #0x0f
    mov     seq_edit_cursor, A
    sjmp    interaction_edit_notes

interaction_edit_notes_cursor_down:
    clr     btn_just_pressed_down
    mov     A, seq_edit_cursor
    inc     A
    anl     A, #0x0f
    mov     seq_edit_cursor, A
    sjmp    interaction_edit_notes

interaction_edit_notes_note_up:
    clr     btn_just_pressed_right
    mov     A, seq_edit_cursor
    add     A, #seq_notes
    mov     R0, A
    mov     A, @R0
    inc     A
    anl     A, #0x07
    mov     @R0, A
    sjmp    interaction_edit_notes

interaction_edit_notes_note_down:
    clr     btn_just_pressed_left
    mov     A, seq_edit_cursor
    add     A, #seq_notes
    mov     R0, A
    mov     A, @R0
    dec     A
    anl     A, #0x07
    mov     @R0, A
    sjmp    interaction_edit_notes



interaction_edit_tempo:
    clr     btn_just_pressed_ok
    setb    display_ss_menu_mode
    orl     seq_edit_cursor, #0x10

    mov     DPTR, #tempo_table_ss_0
    mov     A, tempo_index
    movc    A, @A + DPTR
    mov     ss_menu_value_0, A

    mov     DPTR, #tempo_table_ss_1
    mov     A, tempo_index
    movc    A, @A + DPTR
    mov     ss_menu_value_1, A

    mov     DPTR, #tempo_table_ss_2
    mov     A, tempo_index
    movc    A, @A + DPTR
    mov     ss_menu_value_2, A

interaction_edit_tempo_loop:
    jb      btn_just_pressed_up, interaction_edit_tempo_up
    jb      btn_just_pressed_down, interaction_edit_tempo_down
    jb      btn_just_pressed_ok, interaction_edit_notes
    sjmp    interaction_edit_tempo_loop

interaction_edit_tempo_up:
    clr     btn_just_pressed_up
    mov     A, tempo_index
    cjne    A, #tempo_max_index, _interaction_edit_tempo_up_inc
    sjmp    interaction_edit_tempo_loop
_interaction_edit_tempo_up_inc:
    inc     A
    mov     tempo_index, A
    lcall   tempo_setup_current
    sjmp    interaction_edit_tempo

interaction_edit_tempo_down:
    clr     btn_just_pressed_down
    mov     A, tempo_index
    cjne    A, #0, _interaction_edit_tempo_down_dec
    sjmp    interaction_edit_tempo_loop
_interaction_edit_tempo_down_dec:
    dec     A
    mov     tempo_index, A
    lcall   tempo_setup_current
    sjmp    interaction_edit_tempo



;
; Tempo timer subroutines
;

tempo_init:
    mov     tempo_index, tempo_initial_index
    orl     IE, #(1 << 3)
    setb    TR1

tempo_setup_current:
    mov     DPTR, #tempo_table_th
    mov     A, tempo_index
    movc    A, @A + DPTR
    mov     TH1, A

    mov     DPTR, #tempo_table_tl
    mov     A, tempo_index
    movc    A, @A + DPTR
    mov     TL1, A

tempo_reset_soft_counter:
    mov     DPTR, #tempo_table_sd
    mov     A, tempo_index
    movc    A, @A + DPTR
    mov     tempo_tick, A

    ret


;
; Display control subroutines
;





; Enable display row determined by A
; UB if A >= 16
; Uses A, DPTR
display_row_on:
    mov     DPTR, #display_row_on_tab
    rl      A
    rl      A
    jmp     @A + DPTR   ; jmp display_row_on_tab + row * 4
display_row_on_tab:
    setb    DISPLAY_R0
    ret
; print('\n'.join(f".org display_row_on_tab + (4 * {i})\n    setb DISPLAY_R{i}\n    ret" for i in range(1, 16)))
.org display_row_on_tab + (4 * 1)
    setb DISPLAY_R1
    ret
.org display_row_on_tab + (4 * 2)
    setb DISPLAY_R2
    ret
.org display_row_on_tab + (4 * 3)
    setb DISPLAY_R3
    ret
.org display_row_on_tab + (4 * 4)
    setb DISPLAY_R4
    ret
.org display_row_on_tab + (4 * 5)
    setb DISPLAY_R5
    ret
.org display_row_on_tab + (4 * 6)
    setb DISPLAY_R6
    ret
.org display_row_on_tab + (4 * 7)
    setb DISPLAY_R7
    ret
.org display_row_on_tab + (4 * 8)
    setb DISPLAY_R8
    ret
.org display_row_on_tab + (4 * 9)
    setb DISPLAY_R9
    ret
.org display_row_on_tab + (4 * 10)
    setb DISPLAY_R10
    ret
.org display_row_on_tab + (4 * 11)
    setb DISPLAY_R11
    ret
.org display_row_on_tab + (4 * 12)
    setb DISPLAY_R12
    ret
.org display_row_on_tab + (4 * 13)
    setb DISPLAY_R13
    ret
.org display_row_on_tab + (4 * 14)
    setb DISPLAY_R14
    ret
.org display_row_on_tab + (4 * 15)
    setb DISPLAY_R15
    ret

; Disable display row determined by A
; UB if A >= 16
; Uses A, DPTR
display_row_off:
    mov     DPTR, #display_row_off_tab
    rl      A
    rl      A
    jmp     @A + DPTR   ; jmp display_row_off_tab + row * 4
display_row_off_tab:
    clr     DISPLAY_R0
    ret
; print('\n'.join(f".org display_row_off_tab + (4 * {i})\n    clr DISPLAY_R{i}\n    ret" for i in range(1, 16)))
.org display_row_off_tab + (4 * 1)
    clr DISPLAY_R1
    ret
.org display_row_off_tab + (4 * 2)
    clr DISPLAY_R2
    ret
.org display_row_off_tab + (4 * 3)
    clr DISPLAY_R3
    ret
.org display_row_off_tab + (4 * 4)
    clr DISPLAY_R4
    ret
.org display_row_off_tab + (4 * 5)
    clr DISPLAY_R5
    ret
.org display_row_off_tab + (4 * 6)
    clr DISPLAY_R6
    ret
.org display_row_off_tab + (4 * 7)
    clr DISPLAY_R7
    ret
.org display_row_off_tab + (4 * 8)
    clr DISPLAY_R8
    ret
.org display_row_off_tab + (4 * 9)
    clr DISPLAY_R9
    ret
.org display_row_off_tab + (4 * 10)
    clr DISPLAY_R10
    ret
.org display_row_off_tab + (4 * 11)
    clr DISPLAY_R11
    ret
.org display_row_off_tab + (4 * 12)
    clr DISPLAY_R12
    ret
.org display_row_off_tab + (4 * 13)
    clr DISPLAY_R13
    ret
.org display_row_off_tab + (4 * 14)
    clr DISPLAY_R14
    ret
.org display_row_off_tab + (4 * 15)
    clr DISPLAY_R15
    ret

; Enable column determined by A
; UB if A >= 8
; Uses A, DPTR
display_col_on:
    mov     DPTR, #display_col_on_tab
    rl      A
    rl      A
    jmp     @A + DPTR
display_col_on_tab:
    clr     DISPLAY_C0              ; Columns are negative
    ret
; print('\n'.join(f".org display_col_on_tab + (4 * {i})\n    clr DISPLAY_C{i}\n    ret" for i in range(1, 8)))
.org display_col_on_tab + (4 * 1)
    clr DISPLAY_C1
    ret
.org display_col_on_tab + (4 * 2)
    clr DISPLAY_C2
    ret
.org display_col_on_tab + (4 * 3)
    clr DISPLAY_C3
    ret
.org display_col_on_tab + (4 * 4)
    clr DISPLAY_C4
    ret
.org display_col_on_tab + (4 * 5)
    clr DISPLAY_C5
    ret
.org display_col_on_tab + (4 * 6)
    clr DISPLAY_C6
    ret
.org display_col_on_tab + (4 * 7)
    clr DISPLAY_C7
    ret

display_col_off:
    mov     DPTR, #display_col_off_tab
    rl      A
    rl      A
    jmp     @A + DPTR
display_col_off_tab:
    setb    DISPLAY_C0              ; Columns are negative
    ret
; print('\n'.join(f".org display_col_off_tab + (4 * {i})\n    setb DISPLAY_C{i}\n    ret" for i in range(1, 8)))
.org display_col_off_tab + (4 * 1)
    setb DISPLAY_C1
    ret
.org display_col_off_tab + (4 * 2)
    setb DISPLAY_C2
    ret
.org display_col_off_tab + (4 * 3)
    setb DISPLAY_C3
    ret
.org display_col_off_tab + (4 * 4)
    setb DISPLAY_C4
    ret
.org display_col_off_tab + (4 * 5)
    setb DISPLAY_C5
    ret
.org display_col_off_tab + (4 * 6)
    setb DISPLAY_C6
    ret
.org display_col_off_tab + (4 * 7)
    setb DISPLAY_C7
    ret

; Disable all columns
display_col_off_all:
    setb    DISPLAY_C0
    setb    DISPLAY_C1
    setb    DISPLAY_C2
    setb    DISPLAY_C3
    setb    DISPLAY_C4
    setb    DISPLAY_C5
    setb    DISPLAY_C6
    setb    DISPLAY_C7
    ret

; Disable all rows
display_row_off_all:
    clr     DISPLAY_R0
    clr     DISPLAY_R1
    clr     DISPLAY_R2
    clr     DISPLAY_R3
    clr     DISPLAY_R4
    clr     DISPLAY_R5
    clr     DISPLAY_R6
    clr     DISPLAY_R7
    clr     DISPLAY_R8
    clr     DISPLAY_R9
    clr     DISPLAY_R10
    clr     DISPLAY_R11
    clr     DISPLAY_R12
    clr     DISPLAY_R13
    clr     DISPLAY_R14
    clr     DISPLAY_R15
    ret

; Enable a segment of 7-segment display determined by A
; UB if A >= 8
; Uses A, DPTR
display_ss_segment_on:
    mov     DPTR, #display_ss_segment_on_tab
    rl      A
    rl      A
    jmp     @A + DPTR
display_ss_segment_on_tab:
; print('\n'.join(f".org display_ss_segment_on_tab + (4 * SS_SEGN_{s})\n    setb SMG_{s}\n    ret" for s in (*'ABCDEFG', 'DP')))
.org display_ss_segment_on_tab + (4 * SS_SEGN_A)
    setb SMG_A
    ret
.org display_ss_segment_on_tab + (4 * SS_SEGN_B)
    setb SMG_B
    ret
.org display_ss_segment_on_tab + (4 * SS_SEGN_C)
    setb SMG_C
    ret
.org display_ss_segment_on_tab + (4 * SS_SEGN_D)
    setb SMG_D
    ret
.org display_ss_segment_on_tab + (4 * SS_SEGN_E)
    setb SMG_E
    ret
.org display_ss_segment_on_tab + (4 * SS_SEGN_F)
    setb SMG_F
    ret
.org display_ss_segment_on_tab + (4 * SS_SEGN_G)
    setb SMG_G
    ret
.org display_ss_segment_on_tab + (4 * SS_SEGN_DP)
    setb SMG_DP
    ret

; Disable a segment of 7-segment display determined by A
; UB if A >= 8
; Uses A, DPTR
display_ss_segment_off:
    mov     DPTR, #display_ss_segment_off_tab
    rl      A
    rl      A
    jmp     @A + DPTR
display_ss_segment_off_tab:
; print('\n'.join(f".org display_ss_segment_off_tab + (4 * SS_SEGN_{s})\n    clr SMG_{s}\n    ret" for s in (*'ABCDEFG', 'DP')))
.org display_ss_segment_off_tab + (4 * SS_SEGN_A)
    clr SMG_A
    ret
.org display_ss_segment_off_tab + (4 * SS_SEGN_B)
    clr SMG_B
    ret
.org display_ss_segment_off_tab + (4 * SS_SEGN_C)
    clr SMG_C
    ret
.org display_ss_segment_off_tab + (4 * SS_SEGN_D)
    clr SMG_D
    ret
.org display_ss_segment_off_tab + (4 * SS_SEGN_E)
    clr SMG_E
    ret
.org display_ss_segment_off_tab + (4 * SS_SEGN_F)
    clr SMG_F
    ret
.org display_ss_segment_off_tab + (4 * SS_SEGN_G)
    clr SMG_G
    ret
.org display_ss_segment_off_tab + (4 * SS_SEGN_DP)
    clr SMG_DP
    ret

; Disable all 7-segment display segments
display_ss_segment_off_all:
    clr SMG_A
    clr SMG_B
    clr SMG_C
    clr SMG_D
    clr SMG_E
    clr SMG_F
    clr SMG_G
    clr SMG_DP
    ret

; Disable all 7-segment display digits
display_ss_digit_off_all:
    setb    DISPLAY_D0
    setb    DISPLAY_D1
    setb    DISPLAY_D2
    ret

; Enable a 7-segment digit determined by A
; UB if A >= 3
; Uses A, DPTR
display_ss_digit_on:
    mov     DPTR, #display_ss_digit_on_tab
    rl      A
    rl      A
    jmp     @A + DPTR
display_ss_digit_on_tab:
; print('\n'.join(f".org display_ss_digit_on_tab + (4 * {i})\n    clr DISPLAY_D{i}\n    ret" for i in range(3)))
.org display_ss_digit_on_tab + (4 * 0)
    clr DISPLAY_D0
    ret
.org display_ss_digit_on_tab + (4 * 1)
    clr DISPLAY_D1
    ret
.org display_ss_digit_on_tab + (4 * 2)
    clr DISPLAY_D2
    ret


;
; Input
;



; Checks input, updates btns_pressed, btns_just_pressed
; Uses A, R0
input_check:
    clr     A
    jb      BTN_OK, _input_check_no_ok
    setb    ACC.0
_input_check_no_ok:
    jb      BTN_UP, _input_check_no_up
    setb    ACC.1
_input_check_no_up:
    jb      BTN_DOWN, _input_check_no_down
    setb    ACC.2
_input_check_no_down:
    jb      BTN_RIGHT, _input_check_no_right
    setb    ACC.3
_input_check_no_right:
    jb      BTN_LEFT, _input_check_no_left
    setb    ACC.4
_input_check_no_left:
    mov     R0, A                           ; R0 = pressed_now
    orl     A, btns_denoise_buffer + 3
    orl     A, btns_denoise_buffer + 2
    orl     A, btns_denoise_buffer + 1
    orl     A, btns_denoise_buffer + 0
    mov     btns_denoise_buffer + 3, btns_denoise_buffer + 2
    mov     btns_denoise_buffer + 2, btns_denoise_buffer + 1
    mov     btns_denoise_buffer + 1, btns_denoise_buffer + 0
    mov     btns_denoise_buffer + 0, R0
    mov     R0, A                           ; R0 = A = pressed_filtered
    mov     A, btns_pressed
    cpl     A
    anl     A, R0                           ; A = pressed & ~btns_pressed
    orl     btns_just_pressed, A

    mov     A, R0
    mov     btns_pressed, A
    anl     btns_just_pressed, A            ; btns_just_pressed &= btns_pressed
                                            ; Non-pressed buttons are no longer "just pressed"
    ret



;
; Display main (co)routine
;

; Run one step of display coroutine
display_coro_run:
    push    display_coro_pcl
    push    display_coro_pch
    ret

; End a step of display coroutine
; MUST be called directly from display coroutine only
display_coro_yield:
    pop     display_coro_pch
    pop     display_coro_pcl
    ret

; Display coroutine start
; Calling this will initialize display coroutine and return
display_coro_start:
    acall   display_row_off_all

    acall   display_coro_yield

    mov     display_blink_cnt, #1
display_coro_loop:

; Blinking state update
    djnz    display_blink_cnt, _display_coro_blnk_noover
    cpl     display_blink_on
    mov     display_blink_cnt, #10
_display_coro_blnk_noover:

; 7-segment display
    lcall   display_ss_digit_off_all
    lcall   display_ss_segment_off_all
    clr     A
_display_coro_ss_digits_loop:
    mov     R7, A                       ; R7 = digit index
    lcall   display_ss_digit_on
    mov     A, #ss_anim_value_0
    jnb     display_ss_menu_mode, _display_coro_ss_digits_loop_no_menu
    mov     A, #ss_menu_value_0
_display_coro_ss_digits_loop_no_menu:
    add     A, R7
    mov     R0, A
    mov     6, @R0                      ; R6 = segment bits

    clr     A
_display_coro_ss_segments_loop:
    mov     R5, A                       ; R5 = segment index
    mov     A, R6
    rrc     A
    mov     R6, A
    jnc     _display_coro_ss_segment_off
    mov     A, R5
    lcall   display_ss_segment_on
_display_coro_ss_segment_off:
    lcall   display_coro_yield

    mov     A, R5
    lcall   display_ss_segment_off

    mov     A, R5
    inc     A
    cjne    A, #8, _display_coro_ss_segments_loop

    lcall   display_ss_digit_off_all
    mov     A, R7
    inc     A
    cjne    A, #3, _display_coro_ss_digits_loop


; Matrix display

; Sequence

    lcall   display_col_off_all

    clr     A
_display_notes_loop:
    mov     R5, A                       ; R5 = note index

    cjne    A, seq_edit_cursor, _display_notes_notedit
    jnb     display_blink_on, _display_note_end
_display_notes_notedit:
    lcall   display_row_on

    mov     A, R5
    add     A, #seq_notes
    mov     R0, A
    mov     A, @R0                      ; A = current note
    anl     A, #0x07                    ; (just in case...)
    cjne    A, #0, _display_note_visible
    lcall   display_coro_yield
    sjmp    _display_note_end
_display_note_visible:
    dec     A
    mov     R6, A                       ; R6 = note column
    lcall   display_col_on
    lcall   display_coro_yield
    mov     A, R6
    lcall   display_col_off
_display_note_end:
    mov     A, R5
    lcall   display_row_off

    mov     A, R5
    inc     A
    cjne    A, #16, _display_notes_loop

; Playback cursor

    clr     DISPLAY_C7
    mov     A, seq_cursor
    anl     A, #0x0f
    mov     R5, A
    lcall   display_row_on
    lcall   display_coro_yield
    mov     A, R5
    lcall   display_row_off
    setb    DISPLAY_C7


; End of display coroutine loop
    ljmp    display_coro_loop



;
; Animation (on 7-segment display)
;


animation_init:
    ; TODO: Add multiple animations and choose random one
    mov     anim_ptr, #0
    sjmp    _animation_update_1

animation_frame:
    mov     A, seq_cursor
    cjne    A, #0, _animation_update    ; Restart animation at start of the bar
    sjmp    animation_init

_animation_update:
    djnz    anim_counter, _anim_no_change
_animation_update_1:

    mov     DPTR, #animation_data
    mov     R0, anim_ptr
    mov     A, R0
    movc    A, @A + DPTR
    mov     anim_counter, A
    inc     R0
    mov     A, R0
    movc    A, @A + DPTR
    mov     ss_anim_value_0, A
    inc     R0
    mov     A, R0
    movc    A, @A + DPTR
    mov     ss_anim_value_1, A
    inc     R0
    mov     A, R0
    movc    A, @A + DPTR
    mov     ss_anim_value_2, A
    inc     R0
    mov     anim_ptr, R0


_anim_no_change:
    ret

animation_data:
    .db 8, SS_CHR_0, SS_CHR_U_LOW, SS_CHR_0         ; OuO
    .db 8, SS_CHR_MINUS, SS_CHR_U_LOW, SS_CHR_MINUS ; -u-
    .db 8, SS_CHR_0, SS_CHR_U_LOW, SS_CHR_0         ; 0u0

;
; Sound control routines
;


; Play current note based on seq_* (and TODO current scale)
; Uses A, DPTR
setup_current_note:
    mov     A, #seq_notes
    add     A, seq_cursor
    mov     R0, A
    mov     A, @R0
    anl     A, #0x07
    cjne    A, #0, _setup_current_note_nonzero
    sjmp    mute_sound
_setup_current_note_nonzero:
    dec     A

    add     A, #48 ; TODO: Adjust to scale

    mov     R0, A
    sjmp    setup_note


; Stop playing any sound
mute_sound:
    clr     TR0
    anl     INT_CLKO, #(0xFF - INT_CLKO_T0CLKO)     ; use beeper pin as GPIO
    setb    BEEPER                                  ; pull beeper pin up, so beeper is de-energized
    ret


; Setup T0 to play note determined by R0.
; UB if R0 > 127
; Uses A, DPTR
setup_note:
    mov     DPTR, #notes_table_th
    mov     A, R0
    movc    A, @A+DPTR
    mov     TH0, A

    mov     DPTR, #notes_table_tl
    mov     A, R0
    movc    A, @A+DPTR
    mov     TL0, A

    orl     INT_CLKO, #INT_CLKO_T0CLKO              ; toggle beeper pin on T0 overflow

    ; !!!!!!!!!!! COMMENT TO MUTE IF DEBUGGING GETS ANNOYING !!!!!!!!!!!
    ;setb    TR0

    cjne    R0, #FIRST_X12_NOTE_ID, setup_note_ne
setup_note_need_x12:
    orl     AUXR, #AUXR_T0x12
    ret
setup_note_ne:
    jnc     setup_note_need_x12  ; if R0 > #FIRST_X12_NOTE_ID
    anl     AUXR, #(0xFF - AUXR_T0x12)
    ret



; Note tables
; 1) T2H for each note
notes_table_th:
    .db 0x2         ; Cs0
    .db 0x10        ; D0
    .db 0x1e        ; Ds0
    .db 0x2a        ; E0
    .db 0x36        ; F0
    .db 0x41        ; Fs0
    .db 0x4c        ; G0
    .db 0x56        ; Gs0
    .db 0x60        ; A0
    .db 0x69        ; As0
    .db 0x71        ; B0
    .db 0x79        ; C1
    .db 0x81        ; Cs1
    .db 0x88        ; D1
    .db 0x8f        ; Ds1
    .db 0x95        ; E1
    .db 0x9b        ; F1
    .db 0xa0        ; Fs1
    .db 0xa6        ; G1
    .db 0xab        ; Gs1
    .db 0xb0        ; A1
    .db 0xb4        ; As1
    .db 0xb8        ; B1
    .db 0xbc        ; C2
    .db 0xc0        ; Cs2
    .db 0xc4        ; D2
    .db 0xc7        ; Ds2
    .db 0xca        ; E2
    .db 0xcd        ; F2
    .db 0xd0        ; Fs2
    .db 0xd3        ; G2
    .db 0xd5        ; Gs2
    .db 0xd8        ; A2
    .db 0xda        ; As2
    .db 0xdc        ; B2
    .db 0xde        ; C3
    .db 0xe0        ; Cs3
    .db 0xe2        ; D3
    .db 0xe3        ; Ds3
    .db 0xe5        ; E3
    .db 0xe6        ; F3
    .db 0xe8        ; Fs3
    .db 0xe9        ; G3
    .db 0x2         ; Gs3
    .db 0x10        ; A3
    .db 0x1d        ; As3
    .db 0x2a        ; B3
    .db 0x36        ; C4
    .db 0x41        ; Cs4
    .db 0x4c        ; D4
    .db 0x56        ; Ds4
    .db 0x60        ; E4
    .db 0x68        ; F4
    .db 0x71        ; Fs4
    .db 0x79        ; G4
    .db 0x81        ; Gs4
    .db 0x88        ; A4
    .db 0x8e        ; As4
    .db 0x95        ; B4
    .db 0x9b        ; C5
    .db 0xa0        ; Cs5
    .db 0xa6        ; D5
    .db 0xab        ; Ds5
    .db 0xb0        ; E5
    .db 0xb4        ; F5
    .db 0xb8        ; Fs5
    .db 0xbc        ; G5
    .db 0xc0        ; Gs5
    .db 0xc4        ; A5
    .db 0xc7        ; As5
    .db 0xca        ; B5
    .db 0xcd        ; C6
    .db 0xd0        ; Cs6
    .db 0xd3        ; D6
    .db 0xd5        ; Ds6
    .db 0xd8        ; E6
    .db 0xda        ; F6
    .db 0xdc        ; Fs6
    .db 0xde        ; G6
    .db 0xe0        ; Gs6
    .db 0xe2        ; A6
    .db 0xe3        ; As6
    .db 0xe5        ; B6
    .db 0xe6        ; C7
    .db 0xe8        ; Cs7
    .db 0xe9        ; D7
    .db 0xea        ; Ds7
    .db 0xec        ; E7
    .db 0xed        ; F7
    .db 0xee        ; Fs7
    .db 0xef        ; G7
    .db 0xf0        ; Gs7
    .db 0xf1        ; A7
    .db 0xf1        ; As7
    .db 0xf2        ; B7
    .db 0xf3        ; C8
    .db 0xf4        ; Cs8
    .db 0xf4        ; D8
    .db 0xf5        ; Ds8
    .db 0xf6        ; E8
    .db 0xf6        ; F8
    .db 0xf7        ; Fs8
    .db 0xf7        ; G8
    .db 0xf8        ; Gs8
    .db 0xf8        ; A8
    .db 0xf8        ; As8
    .db 0xf9        ; B8
    .db 0xf9        ; C9
    .db 0xfa        ; Cs9
    .db 0xfa        ; D9
    .db 0xfa        ; Ds9
    .db 0xfb        ; E9
    .db 0xfb        ; F9
    .db 0xfb        ; Fs9
    .db 0xfb        ; G9
    .db 0xfc        ; Gs9
    .db 0xfc        ; A9
    .db 0xfc        ; As9
    .db 0xfc        ; B9
    .db 0xfc        ; C10
    .db 0xfd        ; Cs10
    .db 0xfd        ; D10
    .db 0xfd        ; Ds10
    .db 0xfd        ; E10
    .db 0xfd        ; F10
    .db 0xfd        ; Fs10
    .db 0xfd        ; G10
    .db 0xfe        ; Gs10
; 2) T2L for each note
notes_table_tl:
    .db 0x55        ; Cs0
    .db 0x92        ; D0
    .db 0x2         ; Ds0
    .db 0xb1        ; E0
    .db 0xaa        ; F0
    .db 0xf7        ; Fs0
    .db 0xa1        ; G0
    .db 0xb2        ; Gs0
    .db 0x33        ; A0
    .db 0x2b        ; As0
    .db 0xa2        ; B0
    .db 0xa0        ; C1
    .db 0x2a        ; Cs1
    .db 0x49        ; D1
    .db 0x1         ; Ds1
    .db 0x58        ; E1
    .db 0x55        ; F1
    .db 0xfb        ; Fs1
    .db 0x51        ; G1
    .db 0x59        ; Gs1
    .db 0x19        ; A1
    .db 0x95        ; As1
    .db 0xd1        ; B1
    .db 0xd0        ; C2
    .db 0x95        ; Cs2
    .db 0x24        ; D2
    .db 0x80        ; Ds2
    .db 0xac        ; E2
    .db 0xaa        ; F2
    .db 0x7e        ; Fs2
    .db 0x28        ; G2
    .db 0xad        ; Gs2
    .db 0xd         ; A2
    .db 0x4b        ; As2
    .db 0x69        ; B2
    .db 0x68        ; C3
    .db 0x4b        ; Cs3
    .db 0x12        ; D3
    .db 0xc0        ; Ds3
    .db 0x56        ; E3
    .db 0xd5        ; F3
    .db 0x3f        ; Fs3
    .db 0x94        ; G3
    .db 0xb         ; Gs3
    .db 0x4c        ; A3
    .db 0xc0        ; As3
    .db 0x73        ; B3
    .db 0x70        ; C4
    .db 0xc0        ; Cs4
    .db 0x6d        ; D4
    .db 0x81        ; Ds4
    .db 0x5         ; E4
    .db 0xff        ; F4
    .db 0x79        ; Fs4
    .db 0x79        ; G4
    .db 0x6         ; Gs4
    .db 0x26        ; A4
    .db 0xe0        ; As4
    .db 0x3a        ; B4
    .db 0x38        ; C5
    .db 0xe0        ; Cs5
    .db 0x37        ; D5
    .db 0x41        ; Ds5
    .db 0x2         ; E5
    .db 0x80        ; F5
    .db 0xbc        ; Fs5
    .db 0xbc        ; G5
    .db 0x83        ; Gs5
    .db 0x13        ; A5
    .db 0x70        ; As5
    .db 0x9d        ; B5
    .db 0x9c        ; C6
    .db 0x70        ; Cs6
    .db 0x1b        ; D6
    .db 0xa0        ; Ds6
    .db 0x1         ; E6
    .db 0x40        ; F6
    .db 0x5e        ; Fs6
    .db 0x5e        ; G6
    .db 0x41        ; Gs6
    .db 0xa         ; A6
    .db 0xb8        ; As6
    .db 0x4e        ; B6
    .db 0xce        ; C7
    .db 0x38        ; Cs7
    .db 0x8e        ; D7
    .db 0xd0        ; Ds7
    .db 0x1         ; E7
    .db 0x20        ; F7
    .db 0x2f        ; Fs7
    .db 0x2f        ; G7
    .db 0x21        ; Gs7
    .db 0x5         ; A7
    .db 0xdc        ; As7
    .db 0xa7        ; B7
    .db 0x67        ; C8
    .db 0x1c        ; Cs8
    .db 0xc7        ; D8
    .db 0x68        ; Ds8
    .db 0x0         ; E8
    .db 0x90        ; F8
    .db 0x18        ; Fs8
    .db 0x98        ; G8
    .db 0x10        ; Gs8
    .db 0x82        ; A8
    .db 0xee        ; As8
    .db 0x54        ; B8
    .db 0xb3        ; C9
    .db 0xe         ; Cs9
    .db 0x63        ; D9
    .db 0xb4        ; Ds9
    .db 0x0         ; E9
    .db 0x48        ; F9
    .db 0x8c        ; Fs9
    .db 0xcc        ; G9
    .db 0x8         ; Gs9
    .db 0x41        ; A9
    .db 0x77        ; As9
    .db 0xaa        ; B9
    .db 0xda        ; C10
    .db 0x7         ; Cs10
    .db 0x32        ; D10
    .db 0x5a        ; Ds10
    .db 0x80        ; E10
    .db 0xa4        ; F10
    .db 0xc6        ; Fs10
    .db 0xe6        ; G10
    .db 0x4         ; Gs10
; Index of first note that does need full system frequency
.equ    FIRST_X12_NOTE_ID, 43
; Tempo tables
; 1) TH per tempo
tempo_table_th:
    .db 0x14        ; 20 bpm
    .db 0x8         ; 33.3 bpm
    .db 0x32        ; 40 bpm
    .db 0x48        ; 60 bpm
    .db 0x32        ; 80 bpm
    .db 0x76        ; 120 bpm
    .db 0x14        ; 140 bpm
; 2) TL per tempo
tempo_table_tl:
    .db 0x95        ; 20 bpm
    .db 0x90        ; 33.3 bpm
    .db 0x2         ; 40 bpm
    .db 0xe5        ; 60 bpm
    .db 0x2         ; 80 bpm
    .db 0xac        ; 120 bpm
    .db 0x95        ; 140 bpm
; 3) Software divider per tempo
tempo_table_sd:
    .db 0x7         ; 20 bpm
    .db 0x4         ; 33.3 bpm
    .db 0x4         ; 40 bpm
    .db 0x3         ; 60 bpm
    .db 0x2         ; 80 bpm
    .db 0x2         ; 120 bpm
    .db 0x1         ; 140 bpm
.equ tempo_initial_index, 4
.equ tempo_max_index, 6
; 4.1) Seven-segment first character per tempo
tempo_table_ss_0:
    .db 0, SS_CHR_3, 0, 0, 0, SS_CHR_1, SS_CHR_1
; 4.2) Seven-segment second character per tempo
tempo_table_ss_1:
    .db SS_CHR_2, SS_CHR_3 | SS_SEGB_DP, SS_CHR_4, SS_CHR_6, SS_CHR_8, SS_CHR_2, SS_CHR_4
; 4.3) Seven-segment third character per tempo
tempo_table_ss_2:
    .db SS_CHR_0, SS_CHR_3, SS_CHR_0, SS_CHR_0, SS_CHR_0, SS_CHR_0, SS_CHR_0
